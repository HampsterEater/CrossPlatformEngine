# -*- coding: utf-8 -*-

# ///////////////////////////////////////////////////////////////////////////////
# //  Icarus Game Engine
# //  Copyright © 2011 Timothy Leonard
# ///////////////////////////////////////////////////////////////////////////////	
# 
# This script takes 3 arguments, the first being a directory to scan, the second
# being an output file and the third being the lib output dir. 
# What the script does is go through all cpp files in this folder
# and attempts to generate glue code for any functions that have been marked as 
# script functions.
#
# Functions can be marked using this syntax (the comment must come the line before
# the function prototype).
#
#	// [Script]
#	MyFunction();

# The following values are the only ones that are supported when generating glue
# code for script functions, parameters or return values must be one of these;
#
#	u32				: Parameter will be coerced to an integer.
#	f32				: Parameter will be coerced to a float.
#	CString			: Parameter will be coerced to a string.
#	CScriptContext	: Parameter passed will be the execution context of the script.
#	
# If value is not any of the above, a dynamic_cast will be applied to attempt to convert
# the value into a CScriptObject* which can be used, if that fails, an error occurs.
#
# If you are not generating glue then the function prototype must match the following
# standard script function prototype.
#
#	void MyFunction(CScriptContext* context);
#
# ----------- WARNING ---------------------------------------------------------------
# The generator currently has no knowledge of preprocessor directives, so wrapping
# functions in undefined ifdef's will still cause the glue code to be generated!
# ----------- WARNING --------------------------------------------------------------- 
#	
# Syntax:
#	Scripts\generate_code_glue.py --dir "$(ProjectDir)Engine" --file "$(ProjectDir)Engine\ScriptGlue.h" --libdir "$(SolutionDir)"
# 
# ///////////////////////////////////////////////////////////////////////////////

import os
import time
import datetime
from optparse import OptionParser

hpp_template = """///////////////////////////////////////////////////////////////////////////////
//  Icarus Game Engine
//  Copyright © 2011 Timothy Leonard
///////////////////////////////////////////////////////////////////////////////	
// Generated by generate_code_glue.py
// {timestamp}
///////////////////////////////////////////////////////////////////////////////	
// WARNING: Do not modify this file in any way! It is automatically generated 
//			as part of the build process it should never have to be manually
//			modified.
///////////////////////////////////////////////////////////////////////////////	
#pragma once

#include "CString.h"
#include "CScriptVirtualMachine.h"

{glue_includes}
namespace Engine
{
	namespace Scripting
	{
		class CScriptExecutionContext;
		
		namespace Native
		{
			namespace Glue
			{
				///////////////////////////////////////////////////////////////////////////////	
				// Our pretty glue functions!
				///////////////////////////////////////////////////////////////////////////////	
{glue_definition}

				///////////////////////////////////////////////////////////////////////////////	
				// Registration functions to be called from inside the codebase.
				///////////////////////////////////////////////////////////////////////////////	
				void RegisterScriptFunctions(CScriptVirtualMachine* context);
			}
		}
	}
}
"""

cpp_template = """///////////////////////////////////////////////////////////////////////////////
//  Icarus Game Engine
//  Copyright © 2011 Timothy Leonard
///////////////////////////////////////////////////////////////////////////////	
// Generated by generate_code_glue.py
// {timestamp}
///////////////////////////////////////////////////////////////////////////////	
// WARNING: Do not modify this file in any way! It is automatically generated 
//			as part of the build process it should never have to be manually
//			modified.
///////////////////////////////////////////////////////////////////////////////	

#include "{hpp_file_name}"

#include "CScriptVirtualMachine.h"

namespace Engine
{
	namespace Scripting
	{
		namespace Native
		{
			namespace Glue
			{
				///////////////////////////////////////////////////////////////////////////////	
				// Our pretty glue functions!
				///////////////////////////////////////////////////////////////////////////////	
{glue_implementation}

				///////////////////////////////////////////////////////////////////////////////	
				// Registration functions to be called from inside the codebase.
				///////////////////////////////////////////////////////////////////////////////	
				void RegisterScriptFunctions(CScriptVirtualMachine* context)
				{
{glue_registration}
				}	
			}
		}
	}
}
"""

lib_template = """///////////////////////////////////////////////////////////////////////////////
//  Icarus Game Engine
//  Copyright © 2011 Timothy Leonard
///////////////////////////////////////////////////////////////////////////////	
// Generated by generate_code_glue.py
// {timestamp}
///////////////////////////////////////////////////////////////////////////////	
// WARNING: Do not modify this file in any way! It is automatically generated 
//			as part of the build process it should never have to be manually
//			modified.
///////////////////////////////////////////////////////////////////////////////	

///////////////////////////////////////////////////////////////////////////////	
// Native Functions
///////////////////////////////////////////////////////////////////////////////	
{lib_native_functions}
"""

# Entry point of this application.
def main():

	global hpp_template
	global cpp_template
	global lib_template
	
	parser = OptionParser()
	parser.add_option("-d", "--dir", dest="dir", help="Directory to scan for script functions, this is a required parameter.", metavar="FILE")
	parser.add_option("-f", "--file", dest="filename", help="Filename to write version info to, this is a required parameter.", metavar="FILE")
	parser.add_option("-l", "--libdir", dest="libdir", help="Folder to write output library files to.", metavar="FILE")
	(options, args) = parser.parse_args()
	
	if not options.filename:
		parser.print_usage()
		return
		
	# Work out the output filenames.
	cpp_file_name = os.path.splitext(options.filename)[0] + ".cpp"
	hpp_file_name = os.path.splitext(options.filename)[0] + ".h"
		
	# Calculates all the glue code.
	glue = CalculateGlue(options.dir)
	if (not isinstance(glue, dict)):
		return 1
		
	glue['timestamp'] = datetime.datetime.now().strftime("%d-%m-%Y %H:%M")
	glue['hpp_file_name'] = os.path.basename(hpp_file_name)
	
	# Write out the files.
	OutputTemplate(hpp_template, hpp_file_name, glue)
	OutputTemplate(cpp_template, cpp_file_name, glue)		
	
	# Write out the templates.
	for name, values in glue['libraries'].iteritems():	
		values['lib_native_functions'] = ""			
		values['timestamp'] = datetime.datetime.now().strftime("%d-%m-%Y %H:%M")
		
		for f in glue['functions']:
			if (f['library'].lower() == name.lower()):
				params = []
				for i in f['parameters']:
					params.append(i)
				values['lib_native_functions'] += "function " + f['name'] + "(" + ", ".join(params) + ") = native(\"" + f['name'] + "\");\n"	
			
		OutputTemplate(lib_template, options.libdir + "\\" + name + ".script", values)		
	
	
# Swaps values in the template for their real values and 
# then outputs the result to a file.
def OutputTemplate(template, filename, glue):

	for k, v in glue.iteritems():
		if (isinstance(v, str)):
			template = template.replace("{" + k.lower() + "}", v)
		
	file = open(filename, "w")
	file.write(template)
	file.close()
	
# Looks through the directory provided and attempts to build the glue
# variables used to generate the templates.
def CalculateGlue(dir):

	values = {
		"glue_definition"		:	"",
		"glue_implementation"	:	"",
		"glue_registration"		:	"",
		"glue_includes"			:	"",
		"libraries"				:	{},
		"functions"				:	[]
	}
	
	state = {
		"function_counter"		:	0,
		"used_identifiers"		: 	[]
	}
	
	for dirpath, dirnames, filenames in os.walk(dir):
		for file_path in filenames:
		
			split = os.path.splitext(file_path)
			full_path = os.path.join(dirpath, file_path)
		
			if (split[1] != ".h"):
				continue				
					
			file = open(full_path, "r")
			block_depth = 0
			next_line_is_script_func = False
			namespace = {}
			
			for line in file:
				stripped = line.strip()
				
				# Is this script function?
				if (next_line_is_script_func == True):
					next_line_is_script_func = False
					
					param_start_idx = stripped.find("(")
					param_end_idx   = stripped.find(")")
					if (param_start_idx >= 0 and param_end_idx >= 0):					
						end_of_return_val = stripped.rfind(" ", 0, param_start_idx)
						
						# Extract return value / identifier.
						return_type = stripped[:end_of_return_val].strip()
						identifier  = stripped[end_of_return_val:param_start_idx].strip()
						parameters_split = stripped[param_start_idx + 1:param_end_idx].strip().split(",")
						parameters  = []
						parameter_names = []
						
						for i in parameters_split:
							end_space_idx = i.rfind(" ")

							output = i[:end_space_idx].strip()
							parameters.append(output)						

							output = i[end_space_idx + 1:].strip()
							parameter_names.append(output)
						
						values['functions'].append({
							"library": 			GetLibraryNamespace(namespace),
							"name": 			identifier,
							"parameters": 		parameter_names
						})
						
						# Generate the output.
						if (not CalculateFunctionGlue(values, state, file_path, ConcatNamespaces(namespace), return_type, identifier, parameters)):
							return False
						
				# Inside a block?
				for i in stripped:
					if (i == "}"):
						block_depth -= 1
						
						# Remove namespaces below this depth.
						changed = True
						while (changed == True):
							changed = False
							for k, v in namespace.iteritems():
								if (k >= block_depth):
									changed = True
									del namespace[k]
									break
						
					elif (i == "{"):
						block_depth += 1
				
				# Look at a namespace?
				if (stripped[:9] == "namespace"):
					namespace[block_depth] = stripped[9:].strip() 
				
					k = GetLibraryNamespace(namespace)
					if (k != None):
						if (k not in values['libraries']):						
							values['libraries'][k] = { "name":k }
		
						
				# Looking at a comment?
				if (stripped[:2] == "//"):
					stripped = stripped[2:].strip()
					if (stripped[:1] == "["):
						stripped = stripped[1:]
						end_idx = stripped.find("]")
						if (end_idx >= 0):
							stripped = stripped[:end_idx].strip()
							if (stripped.lower() == "script"):
								next_line_is_script_func = True
							
			file.close()
		
	return values
	
# Get the library namespace.
def GetLibraryNamespace(namespace):	
	full_namespace = ConcatNamespaces(namespace).lower()
	prefix = "engine::scripting::native"
	if (full_namespace[:len(prefix)] == prefix):
		lib_namespace = full_namespace[len(prefix) + 2:]
		if (len(lib_namespace) > 0):
		
			# Only use one level of namespaces.
			split = lib_namespace.split("::")
			split = [ split[0] ]
			
			return split[0]
		
# Takes the definition of a function and generates glue
# for it and places it in the output array provided.
def CalculateFunctionGlue(output, state, header_file, namespace, return_type, identifier, parameters):

	# Make sure function has not been used before.
	if (identifier.lower() in state['used_identifiers']):
		print "ERROR: Attempt to redefine script function that already exists '%s'." % identifier
		return False
	state['used_identifiers'].append(identifier.lower())
		
	# Generate unique name for this glue function.
	glue_function_name		= "ScriptGlue_" + str(state["function_counter"]) + "_" + identifier
	state["function_counter"] = state["function_counter"] + 1
	
	# Include the header in the definition file.
	include_line = "#include \"" + header_file + "\"\n"
	if (output['glue_includes'].find(include_line) < 0):
		output['glue_includes'] = output['glue_includes'] + include_line
	
	# Generate registration code.
	output['glue_registration'] += "context->RegisterNativeFunction(\"" + identifier + "\", &" + glue_function_name + ");\n";
	
	# Generate definition code.
	output['glue_definition'] += "void " + glue_function_name + "(CScriptExecutionContext* context);\n";
	
	# Generate implementation code.
	imp = "void " + glue_function_name + "(CScriptExecutionContext* context)\n";
	imp += "{\n";	
	
	# Clean up parameters.
	clean_params = []
	non_context_param_count = 0
	for p in parameters:
	
		# Remove const-references.
		if (p[:6] == "const "):
			p = p[6:]
		
		# Remove pass by reference references.
		if (p[len(p) - 1:] == "&"):
			p = p[:len(p) - 1]
		
		# Remove namespace.
		colon_end = p.rfind(":")
		if (colon_end >= 0):
			p = p[colon_end + 1:]
		
		# Remove spaces.
		p = p.replace(" ", "")
		
		# Count parameters.
		if (p != "CScriptExecutionContext*"):
			non_context_param_count += 1;
				
		clean_params.append(p)
	
	# Check parameter count is correct.
	imp += "\tif (context->GetParameterCount() != " + str(non_context_param_count) + ")\n"	
	imp += "\t{\n";
	imp += "\t\tcontext->InvalidParameterCount(" + str(non_context_param_count) + ");\n";
	imp += "\t\treturn;\n";
	imp += "\t}\n";
	
	# Put parameters into variables.
	param_index = 0
	param_var_index = 0
	for p in clean_params:
				
		get_param_func_name = "GetParameter";
		perform_cast = False

		if (p.lower() == "u32" or p.lower() == "s32"):
			get_param_func_name = "GetIntParameter";
			
		elif (p.lower() == "f32"):
			get_param_func_name = "GetFloatParameter";
			
		elif (p.lower() == "cstring"):
			get_param_func_name = "GetStringParameter";
			
		else:
			get_param_func_name = "GetObjectParameter";
			perform_cast = True;
				
		# Retrieve the parameter.
		if (p == "CScriptExecutionContext*"):
			imp += "\tCScriptExecutionContext* param" + str(param_var_index) + " = context;\n";	
		else:
			if (perform_cast == True):
				imp += "\t" + parameters[param_var_index] + " param" + str(param_var_index) + " = dynamic_cast<"+parameters[param_var_index]+">(context->" + get_param_func_name + "(" + str(param_index) + "));\n";			
			else:
				imp += "\t" + parameters[param_var_index] + " param" + str(param_var_index) + " = context->" + get_param_func_name + "(" + str(param_index) + ");\n";			
		
		# Increment parameter offset to retrieve.
		if (p != "CScriptExecutionContext*"):
			param_index += 1
		param_var_index += 1

	# Do the call.	
	param_var_index = 0
	
	if (return_type != "void"):
		imp += "\t" + return_type + " return_val = " + namespace + "::" + identifier + "("
	else:
		imp += "\t" + namespace + "::" + identifier + "("
	
	for p in clean_params:
		imp += (", " if param_var_index < len(clean_params) and param_var_index != 0 else "") + "param" + str(param_var_index)
		param_var_index += 1
	imp += ");\n"
		
	# Return the value.
	if (return_type != "void"):

		set_ret_func_name = "SetReturnValue";
		perform_cast = False
		case_to = ""

		if (return_type.lower() == "u32" or return_type.lower() == "s32"):
			set_ret_func_name = "SetReturnIntValue";
			
		elif (return_type.lower() == "f32"):
			set_ret_func_name = "SetReturnFloatValue";
			
		elif (return_type.lower() == "cstring"):
			set_ret_func_name = "SetReturnStringValue";
			
		else:
			set_ret_func_name = "SetReturnObjectValue";
			cast_to = "CScriptObject*"
			perform_cast = True;
			
		if (perform_cast == True):
			imp += "\tcontext->" + set_ret_func_name + "(dynamic_cast<" + cast_to + ">(return_val));\n"
		else:
			imp += "\tcontext->" + set_ret_func_name + "(return_val);\n"
	
	# All done!
	imp += "}\n"
	output['glue_implementation'] += imp	
	
	print "Generated glue for "+namespace+"::"+identifier
	
	return True
	
# Takes a dict in format;
#	{
#		Block_Depth: Namespace
#	}
# And turns it into a string like this;
#	Engine::Platform::X	
def ConcatNamespaces(namespaces):
	str = ""
	for k, v in namespaces.iteritems():
		str += ("::" if str != "" else "") + v 
	return str
	
if __name__=="__main__":
    main();
